var documenterSearchIndex = {"docs":
[{"location":"stats/#StatsAccumulator.jl","page":"Stats Accumulators","title":"StatsAccumulator.jl","text":"","category":"section"},{"location":"stats/","page":"Stats Accumulators","title":"Stats Accumulators","text":"Depth=1","category":"page"},{"location":"stats/","page":"Stats Accumulators","title":"Stats Accumulators","text":"Modules = [MiniObserve.StatsAccumulator]\nOrder   = [:module, :function, :macro, :type]","category":"page"},{"location":"stats/#MiniObserve.StatsAccumulator.CountAcc","page":"Stats Accumulators","title":"MiniObserve.StatsAccumulator.CountAcc","text":"Count number of true values in input. Results are returned as (;n).\n\n\n\n\n\n","category":"type"},{"location":"stats/#MiniObserve.StatsAccumulator.HistAcc","page":"Stats Accumulators","title":"MiniObserve.StatsAccumulator.HistAcc","text":"Track a histogram of input values. Results are returned as a (;bins::Vector{Int}).\n\n\n\n\n\n","category":"type"},{"location":"stats/#MiniObserve.StatsAccumulator.HistAcc-Union{Tuple{}, Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T","page":"Stats Accumulators","title":"MiniObserve.StatsAccumulator.HistAcc","text":"HistAcc()\nHistAcc(min)\nHistAcc(min, width)\nHistAcc(min, width, max; count_below_min, count_above_max)\n\n\nConstruct a histogram accumulator. \n\nArguments:\n\nmin - minimum value [T(0)]\nwidth - bin size [T(1)]\nmax - maximum value. Set lower than or equal to min to let the histogram adjust size automatically. [min]\ncount_below_min - whether values lower than min are ignored or counted in the first bin [false]\ncount_above_max - whether values larger than max are ignored or counted in the last bin [false]\n\n\n\n\n\n","category":"method"},{"location":"stats/#MiniObserve.StatsAccumulator.MaxMinAcc","page":"Stats Accumulators","title":"MiniObserve.StatsAccumulator.MaxMinAcc","text":"Keep track of maximum and minimum of input. Results are returned as (;max, min).\n\n\n\n\n\n","category":"type"},{"location":"stats/#MiniObserve.StatsAccumulator.MeanVarAcc","page":"Stats Accumulators","title":"MiniObserve.StatsAccumulator.MeanVarAcc","text":"Calculate mean and variance of input. Results are given as (;mean, var)\n\n\n\n\n\n","category":"type"},{"location":"stats/#MiniObserve.StatsAccumulator.SumAcc","page":"Stats Accumulators","title":"MiniObserve.StatsAccumulator.SumAcc","text":"Calculate sum of input. Results are returned as (;n).\n\n\n\n\n\n","category":"type"},{"location":"stats/#Index","page":"Stats Accumulators","title":"Index","text":"","category":"section"},{"location":"stats/","page":"Stats Accumulators","title":"Stats Accumulators","text":"","category":"page"},{"location":"README/#MiniObserve.jl","page":"Introduction","title":"MiniObserve.jl","text":"","category":"section"},{"location":"README/","page":"Introduction","title":"Introduction","text":"(Image: CI) (Image: )","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"Minimalist (and minimally intrusive) macro set for extracting information from complex objects, e.g. simulations.","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"Given a number of complicated data structures MiniObserve lets you generate functions to extract and print information from these objects by means of a simple, near declarative interface. It can for example be used to extract information from a simulation model at each time step and write that information to a file.","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"Using MiniObserve has several advantages over hand-written analysis code:","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"a concise declarative interface that puts all information in one place\noutput variables are declared once and output is automatically formatted correctly => adding and removing output variables becomes much less error-prone\na lot of tedious, repetitive and thus brittle code can be avoided","category":"page"},{"location":"README/#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"README/","page":"Introduction","title":"Introduction","text":"Most of the heavy lifting is done by the @observe macro:","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"@observe(statstype, arg1 [, arg2...], declarations)","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"It will generate a custom data type to hold the desired information and an overload of the observe function that - given a model object - will calculate the information and return a data object.","category":"page"},{"location":"README/#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"README/","page":"Introduction","title":"Introduction","text":"As a simple example, let us assume we have the following @observe declaration:","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"@observe Data model user1 user2 begin\n\t@record \"time\"      model.time\n\t@record \"N\"     Int length(model.population)\n\n\tfor ind in model.population \n\t\t@stat(\"capital\", MaxMinAcc{Float64}, MeanVarAcc{FloatT}) <| ind.capital\n\t\t@stat(\"n_alone\", CountAcc)           <| has_neighbours(ind)\n\tend\n\n\t@record u1\t\t\tuser1\n\t@record u2\t\t\tuser1 * user2\nend","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"Then a type Data will be generated that provides (at least) the following members:","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"struct Data\n\ttime :: Float64\n\tN :: Int\n\tcapital :: @NamedTuple{max :: Float64, min :: Float64, mean :: Float64, var :: Float64}\n\tn_alone :: @NamedTuple{N :: Int}\n\tu1 :: Float64\n\tu2 :: Float64\nend","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"Now we can call observe to obtain a data object filled with the corresponding values:","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"m = Model()\ndata = observe(Data, m, 1, 2)","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"And use  print_header and log_results (both exported from MiniObserve) to print the content of that data object to a CSV file or a stream:","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"print_header(stdout, Data)\nlog_results(stdout, data)","category":"page"},{"location":"README/#User-code","page":"Introduction","title":"User code","text":"","category":"section"},{"location":"README/","page":"Introduction","title":"Introduction","text":"Fundamentally @observe's operation is very simple, which makes it very flexible, but also easy to break. Any code in the declaration block will be copied into the observe function verbatim. The only changes @observe applies are:","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"At the beginning of the function a number of local variables containing the single analysis results are created.\nEvery occurence of @record and @stat is replaced with the appropriate code to store the result or add it to an accumulator object (see below), respectively.\nAt the end of the function the constructor of the analysis data type is called, collating all results into one data structure.","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"@observe does not perform any further sanity checks on code outside of the \"pseudo-macros\", so it is the user's responsibility to make sure not to break anything (it is for example a very bad idea to add a return statement to the analysis code).","category":"page"},{"location":"README/#Statistics","page":"Introduction","title":"Statistics","text":"","category":"section"},{"location":"README/","page":"Introduction","title":"Introduction","text":"An important part of MiniObserve is the ability to analyse collections of items by funneling them through \"accumulator\" objects. This is particularly important for models that operate on populations of objects, such as agent-based or individual-based models.","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"In the example above this is used in the expression","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"\tfor ind in model.population \n\t\t@stat(\"capital\", MaxMinAcc{Float64}, MeanVarAcc{FloatT}) <| ind.capital\n\t\t@stat(\"n_alone\", CountAcc)           <| has_neighbours(ind)\n\tend","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"The code generated by the macro iterates through model.population and adds some properties of each element to several accumulators that calculate maximum, minimum, variance and mean or count the number of true predicate values, respectively.","category":"page"},{"location":"README/","page":"Introduction","title":"Introduction","text":"A few simple accumulators are provided in StatsAccumulator. ","category":"page"},{"location":"obs/#Observation.jl","page":"Observation","title":"Observation.jl","text":"","category":"section"},{"location":"obs/","page":"Observation","title":"Observation","text":"Depth=1","category":"page"},{"location":"obs/","page":"Observation","title":"Observation","text":"Modules = [MiniObserve.Observation]\nOrder   = [:module, :function, :macro, :type]","category":"page"},{"location":"obs/#MiniObserve.Observation","page":"Observation","title":"MiniObserve.Observation","text":"This module implements the observation logic itself.\n\n\n\n\n\n","category":"module"},{"location":"obs/#MiniObserve.Observation.joined_named_tuple_T-Tuple","page":"Observation","title":"MiniObserve.Observation.joined_named_tuple_T","text":"concatenate named tuple and/or struct types into one single named tuple\n\n\n\n\n\n","category":"method"},{"location":"obs/#MiniObserve.Observation.log_results-Tuple{Any, Any}","page":"Observation","title":"MiniObserve.Observation.log_results","text":"log_results(out, stats; FS, LS)\n\n\nPrint results stored in stats to output using field separator FS and line separator LS.\n\n\n\n\n\n","category":"method"},{"location":"obs/#MiniObserve.Observation.print_header-Tuple{Any, Any}","page":"Observation","title":"MiniObserve.Observation.print_header","text":"print_header(output, stats_t; FS, NS, LS)\n\n\nPrint a header for an observation type stats_t to output using field separator FS, name separator NS and line separator LS.\n\n\n\n\n\n","category":"method"},{"location":"obs/#MiniObserve.Observation.stat_names-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Observation","title":"MiniObserve.Observation.stat_names","text":"translate accumulator types into prefixes for the header (e.g. min, max, etc.)\n\n\n\n\n\n","category":"method"},{"location":"obs/#MiniObserve.Observation.to_named_tuple-Tuple{Any}","page":"Observation","title":"MiniObserve.Observation.to_named_tuple","text":"construct a named tuple from x\n\n\n\n\n\n","category":"method"},{"location":"obs/#MiniObserve.Observation.tuple_type-Tuple{Any}","page":"Observation","title":"MiniObserve.Observation.tuple_type","text":"obtain a named tuple type with the same field types and names as struct_T\n\n\n\n\n\n","category":"method"},{"location":"obs/#MiniObserve.Observation.@observe-Tuple{Any, Vararg{Any, N} where N}","page":"Observation","title":"MiniObserve.Observation.@observe","text":"@observe(statstype, user_arg1 [, user_arg2...], declarations)\n\nGenerate a full analysis and logging suite for a set of data structures.\n\nObserve expects a (new) type name, a number of user arguments and a block of declarations. It will generate a function observe that takes the user arguments and returns an instance of the data type. The declaration block will be copied verbatim to the body of the observe function, but all occurences of the \"pseudo-macros\" @record and @stat will be replaced with corresponding analysis code. \n\nThe newly defined result data type will contain properties for all calculated results.\n\nSo, given a declaration\n\n@observe Data model stat1 stat2 begin\n\t@record \"time\"      model.time\n\t@record \"N\"     Int length(model.population)\n\n\tfor ind in model.population \n\t\t@stat(\"capital\", MaxMinAcc{Float64}, MeanVarAcc{FloatT}) <| ind.capital\n\t\t@stat(\"n_alone\", CountAcc)           <| has_neighbours(ind)\n\tend\n\n\t@record s1\t\t\tstat1\n\t@record s2\t\t\tstat1 * stat2\nend\n\na type Data will be generated that provides (at least) the following members:\n\nstruct Data\n\ttime :: Float64\n\tN :: Int\n\tcapital :: @NamedTuple{max :: Float64, min :: Float64, mean :: Float64, var :: Float64}\n\tn_alone :: @NamedTuple{N :: Int}\n\ts1 :: Float64\n\ts2 :: Float64\nend\n\nThe macro will also create a method observe(::Type{Data), model, stat1, stat2) that will perform the required calculations and returns a Data object. \n\nUse print_header to print a header for the generated type to an output and log_results to print the content of a data object.\n\n\n\n\n\n","category":"macro"},{"location":"obs/#Index","page":"Observation","title":"Index","text":"","category":"section"},{"location":"obs/","page":"Observation","title":"Observation","text":"","category":"page"},{"location":"statsbase/#StatsAccumulatorBase.jl","page":"StatsAccumulatorBase","title":"StatsAccumulatorBase.jl","text":"","category":"section"},{"location":"statsbase/","page":"StatsAccumulatorBase","title":"StatsAccumulatorBase","text":"Depth=1","category":"page"},{"location":"statsbase/","page":"StatsAccumulatorBase","title":"StatsAccumulatorBase","text":"Modules = [MiniObserve.StatsAccumulatorBase]\nOrder   = [:module, :function, :macro, :type]","category":"page"},{"location":"statsbase/#MiniObserve.StatsAccumulatorBase","page":"StatsAccumulatorBase","title":"MiniObserve.StatsAccumulatorBase","text":"Accumulators can be used to calculate aggregate statistics over sets of elements. In order to be able to work with @observe.@stat an accumulator has to implement the following functions:\n\nadd!(acc, dat) - add a datum to the accumulator. This function has no default implementation.\nresult_type(T) - the type of the result the accumulator generates. Per default it is assumed that this is identical to the accumulator type itself.\nresult(acc) - obtain the current result from the accumulator. Returns the accumulator object itself by default.\n\n\n\n\n\n","category":"module"},{"location":"statsbase/#MiniObserve.StatsAccumulatorBase.add!","page":"StatsAccumulatorBase","title":"MiniObserve.StatsAccumulatorBase.add!","text":"add!(accumulator, value)\n\nAdd a new value to a given accumulator. This function needs to be implemented for new accumulator types.\n\n\n\n\n\n","category":"function"},{"location":"statsbase/#MiniObserve.StatsAccumulatorBase.result_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"StatsAccumulatorBase","title":"MiniObserve.StatsAccumulatorBase.result_type","text":"result_type(_)\n\n\nReturns the type of the results of accumulator T. \n\nPer default the accumulator type itself is assumed to form the result. Overload for custom result types.\n\n\n\n\n\n","category":"method"},{"location":"statsbase/#MiniObserve.StatsAccumulatorBase.results-Tuple{T} where T","page":"StatsAccumulatorBase","title":"MiniObserve.StatsAccumulatorBase.results","text":"results(t)\n\n\nReturn the results of an accumulator.\n\nPer default it is assumed that the accumulator type contains the result. Overload for custom result types. \n\n\n\n\n\n","category":"method"},{"location":"statsbase/#Index","page":"StatsAccumulatorBase","title":"Index","text":"","category":"section"},{"location":"statsbase/","page":"StatsAccumulatorBase","title":"StatsAccumulatorBase","text":"","category":"page"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"}]
}
